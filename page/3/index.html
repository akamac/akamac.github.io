<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
	<meta name="generator" content="Hugo 0.49.2" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      PurpleScreen &middot; blog about open source
    
  </title>

  
  <link rel="stylesheet" href="https://purple-screen.com/css/poole.css">
  <link rel="stylesheet" href="https://purple-screen.com/css/syntax.css">
  <link rel="stylesheet" href="https://purple-screen.com/css/lanyon.css">
  <link rel="stylesheet" href="https://purple-screen.com/css/custom.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://purple-screen.com/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://purple-screen.com/assets/favicon.png">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://purple-screen.com/atom.xml">
</head>


  
  <body>

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Blog about IT</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item  active " href="https://purple-screen.com/">Home</a>
    <a class="sidebar-nav-item " href="https://purple-screen.com/post">Posts</a>

    
    
      
        <a class="sidebar-nav-item " href="https://purple-screen.com/about/">About</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

  </nav>

  <div class="sidebar-item">
    <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
    <p>Hosted on <a href="https://pages.github.com/">GitHub Pages</a> and <a href="https://cloudflare.com">CloudFlare</a>.</p>
    <p>&copy; 2014</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://purple-screen.com/" title="Home">PurpleScreen</a>
            <small>blog about open source</small>
            
          </h3>
        </div>
      </div>

      <div class="container content">





<div class="posts">
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2013/07/21/enumerating-through-hashtable-in-posh/">Enumerating through hashtable in PoSH</a></h1>
        <span class="post-date">Jul 21 2013</span>
        <pre class="expand:true lang:ps decode:true " >$ht = @{a=1; b=2; c=3}
$ht.GetEnumerator() | % { $_.key; $_.value }</pre>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2013/07/20/join-object/">Join-Object</a></h1>
        <span class="post-date">Jul 20 2013</span>
        <p>If you ever wrote SQL queries and now use PowerShell for scripting maybe you missed &#8216;Join&#8217; possibility in PoSH. Here it is!</p>

<p>Nothing special. I just tried to create Join-Object with the same functionality as inner/outer Join statements in SQL. My version of Join-Object uses standalone Merge-Object function for merging 2 arrays of custom objects / hashtables. Resulting object is an array of objects that contains all properties from joined objects except the ones with the same name, which are discarded. If you also want to include the property on which you join the collections use $IncludeJoinProperty switch. The expression for specifying the property to join on is that simple:</p>

<p><span class="minimize:true lang:ps decode:true  crayon-inline " >-On {$Left.&#8217;propertyName&#8217; -eq $Right.&#8217;propertyName&#8217;}</span></p>

<p>Collections to be joined must contain objects of the same type otherwise the error is generated. Also function throws an error in case of the values of join property in collection (left or right) are not unique. Merge and Join aliases added by default.</p>

<p>If you have any questions drop me a line in comments. Use it on your own risk :)</p>

<pre class="expand:true lang:ps decode:true " title="Join-Object" >function Merge-Object {
    Param (
        [Parameter(Mandatory,ValueFromPipeline)]
        [Object] $First,
        [Parameter(Mandatory,ValueFromPipeline)]
        [Object] $Second
    )
    if ($First -is [HashTable] -and $Second -is [HashTable]) { $First + $Second; return }
    if ($First -is [HashTable]) { $First = New-Object PSObject -Property $First }
    if ($Second -is [HashTable]) { $First = New-Object PSObject -Property $Second }
    $FirstProperties = ($First | gm -MemberType Properties).Name
    $Merged = $First | Select $FirstProperties
    $Second | gm -MemberType Properties | ? Name -notin $FirstProperties |
    % { $Merged | Add-Member -MemberType NoteProperty -Name $_.Name -Value $Second.($_.Name) }
    $Merged
}
if (-not (Test-Path Alias:\Merge)) { New-Alias Merge Merge-Object }
 
function Join-Object {
    Param (
        [Parameter(Mandatory)]
        [Object[]] $Left,
        [Parameter(Mandatory)]
        [Object[]] $Right,
        [Parameter(Mandatory)]
        [ValidateSet('Inner','OuterLeft','OuterRight','Outer')]
        [string] $Type,
        [Parameter(Mandatory)]
        [ScriptBlock] $On,
        [switch] $IncludeJoinProperty
    )
    if (($Left | % { $_.GetType() } | Select -Unique).Count -gt 1) { throw 'Left array is not homogeneous' }
    if (($Right | % { $_.GetType() } | Select -Unique).Count -gt 1) { throw 'Right array is not homogeneous' }
    # get properties names to join on
    if ($On.ToString() -match "[\$]Left\.(\S+)") { $LeftProperty = $Matches[1] }
    if ($On.ToString() -match "[\$]Right\.(\S+)") { $RightProperty = $Matches[1] }
    # ensure the properties' values are unique
    if (@($Left.$LeftProperty | Select -Unique).Count -lt $Left.Count) {
        throw "Specified property's values in left array are not unique" }
    if (@($Right.$RightProperty | Select -Unique).Count -lt $Right.Count) {
        throw "Specified property's values in right array are not unique" }
    $Result = @()
    # convert hashtables to psobjects
    if ($Left[0] -is [HashTable]) { for ($i = 0; $i -lt $Left.Count; $i++) { $Left[$i] = New-Object PSObject -Property $Left[$i] } }
    if ($Right[0] -is [HashTable]) { for ($i = 0; $i -lt $Right.Count; $i++) { $Right[$i] = New-Object PSObject -Property $Right[$i] } }
    # stub objects for outer joins
    $Properties = New-Object System.Collections.Hashtable
    ($Left[0] | gm -MemberType Properties).Name | % { $Properties.Add($_, $null) }
    $LeftStubObj = New-Object PSObject -Property $Properties
 
    $Properties = New-Object System.Collections.Hashtable
    ($Right[0] | gm -MemberType Properties).Name | % { $Properties.Add($_, $null) }
    $RightStubObj = New-Object PSObject -Property $Properties
 
    if ($Type -eq 'OuterRight') {
        # swap objects and properties
        Join $Right $Left OuterLeft ([ScriptBlock]::Create("`$Left.$RightProperty -eq `$Right.$LeftProperty")) `
        -IncludeJoinProperty:($IncludeJoinProperty.IsPresent)
        return
    }
 
    foreach ($LeftObj in $Left) {
        $Found = $false
        foreach ($RightObj in $Right) {
            if (& ([ScriptBlock]::Create(($On.ToString() -replace "[\$]Left(.*)[\$]Right(.*)","`$LeftObj`$1`$RightObj`$2")))) {
                if ($Type -match "Outer*") { $Found = $true }
                $Result += $LeftObj | Merge $RightObj | Select -ExcludeProperty $LeftProperty, $RightProperty `
                $(if ($IncludeJoinProperty.IsPresent) { '*', @{N='JOIN';E={$_.($LeftProperty)}} } Else { '*' } )
                $Right = $Right -ne $RightObj
                break
            }
        }
        if (!$Found -and $Type -match "Outer*") {
            $Result += $LeftObj | Merge $RightStubObj | Select -ExcludeProperty $RightProperty, $LeftProperty `
            $(if ($IncludeJoinProperty.IsPresent) { '*', @{N='JOIN';E={$_.($LeftProperty)}} } else { '*' } )
        }
    }
    if ($Type -eq 'Outer') {
        $Right | % { $Result += $_ | Merge $LeftStubObj | Select -ExcludeProperty $LeftProperty, $RightProperty `
        $(if ($IncludeJoinProperty.IsPresent) { '*', @{N='JOIN';E={$_.($RightProperty)}} } else { '*' } )
        }
    }
    $Result
}
if (-not (Test-Path Alias:\Join)) { New-Alias Join Join-Object }</pre>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2013/07/19/must-read-posh-book/">Must read PoSH book</a></h1>
        <span class="post-date">Jul 19 2013</span>
        <p>If you start learning PowerShell then reading <a href="http://www.amazon.com/Windows-PowerShell-Action-Second-Edition/dp/1935182137" title="Windows PowerShell in Action, 2nd Edition" target="_blank">Windows PowerShell in Action, 2nd Edition</a> by Bruce Payette is a must! He is among the principal members of PowerShell team and explain guts of the language in detail.</p>

<p>Again, MUST READ!</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2013/06/15/foreach-cmdlet-vs-keyword/">ForEach: cmdlet vs keyword</a></h1>
        <span class="post-date">Jun 15 2013</span>
        <p>Here is a little note about the difference of these two loop constructions.</p>

<p><em>foreach</em> is a reserved keyword in PoSH that allows you to loop through collection of objects and make some action on every item. Inside the foreach loop <em>$foreach</em> automatic variable is available. It presents the loop enumerator and can be used, for instance, to skip the current object in collection (.MoveNext() method).</p>

<p><em>ForEach-Object</em> is a cmdlet doing almost the same thing but the difference is the usecase. Since the collection is piped to the cmdlet the objects are pushed down the pipeline as soon as they are generated. It affects the performance greatly when a collection isn&#8217;t created at the start of processing. When the last is long-time operation using the cmdlet you can achieve much better overall performance than using its brother-keyword. In other case one should consider using the keyword for higher execution speed.</p>

<p>Since both have the same alias foreach the PoSH parser is smart enough to select the appropriate construction depending on the place it is used.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2013/05/31/vmware-uuids/">VMware UUIDs</a></h1>
        <span class="post-date">May 31 2013</span>
        <p>Hi everybody! My first post is about UUIDs &#8211; identifiers used for virtual machines in vSphere infrastructure. If you ever looked in vm config file (*.vmx) you could see 3 different lines containing 128-bit hex numbers. They are:</p>

<ul>
<li>uuid.bios</li>
<li>uuid.location</li>
<li>vc.uuid</li>
</ul>

<p>Because of having some issues with software licensing inside guest OS I decided to explore what the every value is responsible for. Web hasn&#8217;t gave me the complete answer about the meaning of all of these parameters so my investigations led me to the following conclusion I&#8217;d like to share with you.</p>

<p><strong>uuid.bios</strong> &#8211; this value acts as GUID analog in physical machine, you should keep it to make the license not to get broken. If you want to export VM, for example using vCenter Converter, and run it in VMware Player/Workstation you should also add the following line to exported vmx file together with copying the source uuid.bios value:</p>

<p><span style="padding-left: 10%"><em>uuid.action = &#8220;keep&#8221;</em></span></p>

<p>It prevents player/workstation from asking whether you moved or copied VM with default answer &#8220;I moved it&#8221;. If the valid uuid.bios line is present in config file it will be preserved and the software license will be OK. Another option for uuid.action is &#8220;change&#8221;. In this case VMware will generate the value when you power on VM in new location (host or even folder). You can read <a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=1541">this KB article</a> to learn more about it. So the uuid.bios setting is done. Let&#8217;s look through others two.</p>

<p><strong>uuid.location</strong> is generated every time VM is vMotion&#8217;ed to another host/storage. I guess it&#8217;s used by vCenter for some internal purposes like ..</p>

<p><strong>vc.uuid</strong> is used by vCenter to identify VM together with MoRef ID you&#8217;ve seen while working with PowerCLI. It&#8217;s unique and is generated when you add VM to inventory (or create VM). If the value is already present in config file (and there is no duplicate in current inventory) it&#8217;s left intact.</p>

<p>That&#8217;s enough for the first post. In the end &#8211; a little piece of PowerShell code to automate the postprocessing of exported VM to ensure its uuid.bios value is the same as source vm&#8217;s. It guarantees the persistence of all licenses that depends on GUID.</p>

<pre class="expand:true lang:ps decode:true " title="Keep BIOS UUID for exported VM" >function Keep-BiosUuid {
    Param (
        [Parameter(Mandatory,HelpMessage='VM name',ValueFromPipelineByPropertyName)]
        [string[]] $Name,
        [Parameter(Mandatory)]
        [string] $Datacenter,
        [Parameter(Mandatory)]
        [string] $ExportedPath
    )
    foreach ($VmName in $Name) {
        $VM = Get-VM $VmName
        $VmConfig = Copy-DatastoreItem -Destination $env:TEMP -PassThru `
        -Item "vmstore:\\$Datacenter\\$($VM.ExtensionData.Config.Files.VmPathName -replace '\\[([^\\]]+)\\] ([^/]+)/(.*)','$1\\$2\\$3')"
        Add-Content "$ExportedPath\\$VmName\\$VmName.vmx" ((cat $VmConfig | sls 'uuid.bios'), 'uuid.action = "keep"')
        rm $VmConfig -Confirm:$False
    }
}</pre>

<p>Hope you&#8217;ll find it useful. Stay tuned, keep learning!</p>

    </div>
  
</div>

<div class="pagination">
  
  <span class="pagination-item older">Older</span>
  

  
  <a class="pagination-item newer" href="https://purple-screen.com/page/2/">Newer</a>
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>
</html>

