<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
	<meta name="generator" content="Hugo 0.49.2" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      PurpleScreen &middot; blog about open source
    
  </title>

  
  <link rel="stylesheet" href="https://purple-screen.com/css/poole.css">
  <link rel="stylesheet" href="https://purple-screen.com/css/syntax.css">
  <link rel="stylesheet" href="https://purple-screen.com/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  <link rel="stylesheet" href="https://purple-screen.com/css/custom.css">
  
  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://purple-screen.com/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://purple-screen.com/assets/favicon.png">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://purple-screen.com/atom.xml">
</head>


  
  <body>

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Blog about IT</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item  active " href="https://purple-screen.com/">Home</a>
    <a class="sidebar-nav-item " href="https://purple-screen.com/post">Posts</a>

    
    
      
        <a class="sidebar-nav-item " href="https://purple-screen.com/about/">About</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

  </nav>

  <div class="sidebar-item">
    <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
    <p>Hosted on <a href="https://pages.github.com/">GitHub Pages</a> and <a href="https://cloudflare.com">CloudFlare</a>.</p>
    <p>&copy; 2014</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://purple-screen.com/" title="Home">PurpleScreen</a>
            <small>blog about open source</small>
            
          </h3>
        </div>
      </div>

      <div class="container content">





<div class="posts">
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2014/07/23/expand-rdm-in-virtual-compatibility-mode/">Expand RDM in virtual compatibility mode</a></h1>
        <span class="post-date">Jul 23 2014</span>
        <p>As opposed to the physical RDM mode with the virtual one after expanding the LUN on the storage array side and rescanning HBA vm still can&#8217;t see the increased capacity. The official VMware tutorial says to shutdown vm and re-add RDM. This isn&#8217;t acceptable. The hint to make it happen with no downtime is to vMotion vm after rescanning HBA on the destination host. That&#8217;s it!</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2014/06/10/manage-zip-archives-with-powershell/">Manage Zip archives with PowerShell</a></h1>
        <span class="post-date">Jun 10 2014</span>
        <p>I know there are lots of examples and function implementations out there (for instance, the one <a title="Jaykul" href="http://huddledmasses.org/a-new-way-to-zip-and-unzip-in-powershell-3-and-net-4-5/" target="_blank">from jaykul</a>), nonetheless I&#8217;d like to add my 2 cents. Even 5c, since my version is more powerful :) It allows you to set compression level, append/replace files to/in existing archives and extract only necessary files from archive.</p>

<p>For instance, to extract <em>vmware.xml</em> file from the archive&#8217;s root and all the files from the <em>vib</em> folder stored in root also (yep, we&#8217;re expanding metadata.zip), creating subfolder in the current directory (replacing if already exists), you need to run the following command:</p>

<p><span class="lang:default decode:true  crayon-inline">Extract-ZipFile -ZipFilePath metadata.zip -FilesToExtract vmware.xml,vibs/ -CreateSubfolder -Force</span></p>

<p>The slash character indicates that you&#8217;d like to expand the folder, not the file.</p>

<pre class="expand:true lang:ps decode:true" title="Zip archives manipulation">Add-Type -As System.IO.Compression.FileSystem

function New-ZipFile {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory,ValueFromPipeline)]
        [string[]] $InputObject,
        [Parameter(Mandatory)]
        [string] $ZipFilePath,
        [ValidateSet('Optimal','Fastest','NoCompression')]
        [System.IO.Compression.CompressionLevel] $Compression = 'Optimal',
        [switch] $Append,
        [switch] $Force
    )
    Begin {
        if (-not (Split-Path $ZipFilePath)) { $ZipFilePath = Join-Path $Pwd $ZipFilePath }
        if (Test-Path $ZipFilePath) {
            if ($Append.IsPresent) {
                Write-Verbose 'Appending to the destination file'
                $Archive = [System.IO.Compression.ZipFile]::Open($ZipFilePath,'Update')
            } elseif ($Force.IsPresent) {
                Write-Verbose 'Removing the destination file'
                Remove-Item $ZipFilePath
                $Archive = [System.IO.Compression.ZipFile]::Open($ZipFilePath,'Create')
            } else {
                Write-Error 'Output file already exists. Specify -Force option to replace it or -Append to add/replace files in existing archive'
                break
            }
        } else {
            $Archive = [System.IO.Compression.ZipFile]::Open($ZipFilePath,'Create')
        }
    }
    Process {
        foreach ($Obj in $InputObject) {
            try {
                switch ((Get-Item $Obj -ea Stop).GetType().Name) {
                    FileInfo {
                        $EntryName = Split-Path $Obj -Leaf
                        $Entry = $Archive.Entries | ? FullName -eq $EntryName
                        if ($Entry) {
                            if ($Force.IsPresent) {
                                Write-Verbose "Removing $EntryName from the archive"
                                $Entry.Delete()
                            } else {
                                throw "File $EntryName already exists in the archive"
                            }
                        }
                        $Verbose = [System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile($Archive,$Obj,$EntryName,$Compression)
                        Write-Verbose $Verbose
                    }
                    DirectoryInfo {
                        Push-Location $Obj
                        (Get-ChildItem . -Recurse -File).FullName | % {
                            $EntryName = (Join-Path (Split-Path $Obj -Leaf) (Resolve-Path $_ -Relative).TrimStart('.\')) -replace '\\','/'
                            $Entry = $Archive.Entries | ? FullName -eq $EntryName 
                            if ($Entry) {
                                if ($Force.IsPresent) {
                                    Write-Verbose "Removing $EntryName from the archive"
                                    $Entry.Delete()
                                } else {
                                    throw "File $EntryName already exists in the archive"
                                }
                            }
                            $Verbose = [System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile($Archive,$_,$EntryName,$Compression)
                            Write-Verbose $Verbose
                        }
                        Pop-Location
                    }
                }
            } catch {
                Write-Error $_
                $Archive.Dispose()
                Pop-Location
                if ($_.CategoryInfo.TargetType -ne [string] -and -not $Append.IsPresent) {
                    Remove-Item $ZipFilePath
                }
                return
            }
        }
    }
    End {
        $Archive.Dispose()
        Get-Item $ZipFilePath
    }
}

function Extract-ZipFile {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory,ValueFromPipeline)]
        [string] $ZipFilePath,
        [string] $OutputPath = $Pwd,
        [string[]] $FilesToExtract = '*',
        [switch] $CreateSubfolder,
        [Parameter(HelpMessage='Replace files in destination if exist')]
        [switch] $Force
    )
    try {
        $Archive = [System.IO.Compression.ZipFile]::Open($ZipFilePath,'Read')
        if ($CreateSubfolder.IsPresent) {
            $Destination = New-Item (Join-Path $OutputPath (Get-Item $ZipFilePath).BaseName) -ItemType Directory -Force:($Force.IsPresent) -ea Stop
        } elseif (Test-Path $OutputPath) {
            $Destination = Get-Item $OutputPath
        } else {
            $Destination = New-Item $OutputPath -ItemType Directory -ea Stop
        }
        Write-Verbose "Destination path: $($Destination.FullName)"
        Push-Location $Destination
        $FilesToExtract = $FilesToExtract | % {
            for ($FullPath = $_; $FullPath; $FullPath = (Split-Path $FullPath -Parent) -replace '\\','/') {$FullPath}
        }
        $FoldersToExtract = $FilesToExtract | ? {$_.EndsWith('/')}
        $Entries = ?: {$FilesToExtract -ne '*'} { $Archive.Entries | ? {
            $_.FullName.TrimEnd('/') -in $FilesToExtract -or
            $_.FullName -like "$FoldersToExtract*"
        } } { $Archive.Entries }
        $Extracted = $false
        $Entries | Sort Name,FullName | % {
            if (-not $_.Name) {
                $Verbose = New-Item -Path $_.FullName -ItemType Directory -Force:($Force.IsPresent) -ea Stop
                Write-Verbose "$Verbose created"
            } else {
                Write-Verbose "Extracting $($_.FullName)"
                $DestPath = Join-Path $Destination $_.FullName
                if (-not (Test-Path (Split-Path $DestPath))) {
                    $Verbose = New-Item -Path (Split-Path $DestPath) -ItemType Directory -Force:($Force.IsPresent) -ea Stop
                    Write-Verbose "$Verbose created"
                }
                [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_,$DestPath,$Force.IsPresent)
                $Extracted = $true
            }
        }
        #return $Extracted
    } catch {
        Write-Error $_
        return
    } finally {
        Pop-Location
        $Archive.Dispose()
    }
}</pre>

<p>&nbsp;</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2014/06/10/obn-object-by-name-transformation/">OBN (Object By Name) transformation</a></h1>
        <span class="post-date">Jun 10 2014</span>
        <p>You might have known that most of PowerCLI cmdlets parameters accept objects or object names (with wildcard characters allowed). Take a look at New-VM cmdlet: you can pass strings to VMHost, ResourcePool, Datastore, etc. parameters as well as the objects itself. Or maybe you&#8217;ve even never noticed this since it just works!</p>

<p>Want the same behavior for your own functions? No problem! Use the function below to perform transparent transformation from any eligible object to the object you need (View or Impl). The neat feature it has is limiting the retrieved properties for view object, what considerably improves performance in some cases.</p>

<p>This is how to integrate it to your own function:</p>

<p>The one thing you should be aware of is that it accepts wildcards, while you may think the regular expressions are more powerful tool (and I completely agree with you). The reason I had in mind was to not to confuse users who got used to the default PowerCLI behavior. It&#8217;s up to you to remove <em>ConvertTo-Regex</em> part from <em>-Filter</em> parameter in <em>Get-View</em> call. But in this case sometimes you might be puzzled when the script can&#8217;t find an object with the name you are hundred percent sure exists. Doh! Any braces in the name? Use <em>[regex]::Escape()</em> to escape them.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2014/06/10/retrieve-cdp/lldp-info/">Retrieve CDP/LLDP info</a></h1>
        <span class="post-date">Jun 10 2014</span>
        <p>Search for an easy way to get CDP/LLDP info for any given ESXi physical port (vmnic)? Here it is!</p>

<p>It relies on ObnTransformation from my <a title="OBN transformation" href="http://purple-screen.com/?p=447" target="_blank">previous post</a> and also depends on <a title="PowerShell Community Extensions" href="http://pscx.codeplex.com/" target="_blank">PowerShell Community Extensions</a> for ?? alias (Invoke-NullCoalescing). You can replace the latter with the simple <em>if</em> in case you don&#8217;t have PSCX installed.</p>

<p>Keep in mind that (some) devices return MAC instead of the management IP in LLDP info.</p>

<p>By default all vmnics are queried.</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2014/05/10/convert-psobject-to-hashtable/">Convert PSObject to hashtable</a></h1>
        <span class="post-date">May 10 2014</span>
        <pre class="expand:true lang:ps decode:true crayon-selected" title="Convert PSObject to hashtable">function ConvertTo-Hashtable {
    Param (
        [Parameter(Mandatory,ValueFromPipeline)]
        [PSObject[]] $Object
    )
    Process {
        foreach ($obj in $Object) {
            $ht = [ordered]@{}
            $obj | Get-Member -MemberType *Property | % {
                $ht.($_.Name) = $obj.($_.Name)
            }
            $ht
        }
    }
}</pre>

<p>&nbsp;</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2014/05/09/mysql-database-manipulation-from-powershell/">MySQL database manipulation from PowerShell</a></h1>
        <span class="post-date">May 9 2014</span>
        <p>Download <a title="MySQL Connector/NET" href="http://dev.mysql.com/downloads/connector/net/" target="_blank">MySQL Connector/NET</a> first.</p>

<pre class="expand:true lang:ps decode:true" title="Access MySQL db from PowerShell">Add-Type -Path 'C:\Program Files (x86)\MySQL\MySQL Connector Net 6.8.3\Assemblies\v4.5\MySql.Data.dll'
$Connection = [MySql.Data.MySqlClient.MySqlConnection]@{ConnectionString='server=&lt;FQDN&gt;;uid=&lt;user&gt;;pwd=&lt;password&gt;;database=&lt;db&gt;'}
$Connection.Open()

$Command = $Connection.CreateCommand()
$Command.CommandText = "SELECT .. FROM .. WHERE .."
$Reader = $Command.ExecuteReader()

while ($Reader.Read()) {
    # $Reader array variable represents the table row
}

$Reader.Close()
$Connection.Close()</pre>

<p>&nbsp;</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2014/02/05/the-power-of-get-view/">The power of Get-View</a></h1>
        <span class="post-date">Feb 5 2014</span>
        <p>Today we&#8217;re going to discover very useful Get-View cmdlet. I&#8217;m sure most of you have seen it in many scripts found across the web. This cmdlet returns .NET view objects thus exposing API methods and properties to PowerShell environment. This is crucial in advanced manipulating with vSphere infrastructure.</p>

<p>First it&#8217;s worth mentioning that getting implementation objects (those produced by Get-VM, Get-VMHost, etc) takes more time than getting view objects, though in the last versions I found the gap decreased significantly. In fact impl objects are composed of the properties of corresponding view objects.</p>

<p>Let&#8217;s discover the available parameters that need to be discussed:</p>

<p><strong>-VIObject, -Id</strong></p>

<p>View object can be retrieved by MoRef (-Id) or by passing the impl object (-VIObject) to cmdlet. Don&#8217;t forget to use -Server parameter when retrieving objects by MoRef if you are working with multiple <em>default</em> vCenter servers since MoRef are not unique across different vCenter servers.</p>

<p><strong>-Property</strong></p>

<p>This parameter allows you to limit the object properties to be retrieved that can significantly speed up the query execution. Going ahead, one interesting thing you may wonder while using this parameter together with -Filter: does the property that objects are filtered by need to be specified here? The answer is no, they don&#8217;t.</p>

<p><strong>-Filter</strong></p>

<p>This parameter accepts the hash table:</p>

<p><span class="lang:default decode:true  crayon-inline crayon-selected">@{Name=&#8217;^TestVM[1-9]$&#8217;; &#8216;Config.Version&#8217;=&#8217;7&#8217;; &#8216;Snapshot&#8217;=&#8221;}</span></p>

<p>where both keys and values represent the strings and imply that for any object returned every specified key must match the corresponding value. The key can be any nested property but not the property of linked object &#8211; for linked objects use -SearchRoot parameter (more on that later). You can use the power of regular expressions for value strings. You may wonder how to test whether the property exists for the object? Just specify this property with the empty value. The example above will filter all vms with name matching &#8216;TestVM&#8217;, hardware version equal to &#8216;vmx-07&#8217; and for which at least one snapshot exists.</p>

<p>Filtering on the server side prevents the objects that don&#8217;t satisfy the specified criteria to be transfered to the client thus it again increases the performance.</p>

<p><strong>-ViewType</strong></p>

<p>Unfortunately cmdlet implementation is missing the list of possible values for this parameter (any reason this can&#8217;t be implemented?). You can find out accepted viewtypes by calling Get-View with any incorrect string. Having the list it&#8217;s easy to understand which type to use in a query. To learn more about types, inheritance and so on go to <a title="API reference guide" href="http://pubs.vmware.com/vsphere-55/index.jsp?topic=%2Fcom.vmware.wssdk.apiref.doc%2Fright-pane.html" target="_blank">API reference guide</a>.</p>

<p>Another really useful objects that can be retrieved by Get-View are different types of managers. The full list can be obtained with &#8216;(Get-View ServiceInstance).Content&#8217; call.</p>

<p>One can use them to manipulate alarms (Get-View AlarmManager), tasks (Get-View TaskManager), files and so on. So it&#8217;s very useful stuff too.</p>

<p>Ok, this part is done. Now let&#8217;s explore the base view object.</p>

<p>We have an interesting liaison here: <strong>UpdateViewData</strong> method and <strong>LinkedView</strong> property.</p>

<p>Until UpdateViewData is invoked the LinkedView property is empty. Parameters of UpdateViewData invocation are the (multiple) properties of current or linked object you want to obtain. Together with the property name we can specify the property object type. In some cases it&#8217;s quite useful to restrict the possible values if the property is the list of object of different types. Let&#8217;s see an example because the code is better than thousand words. Consider navigating through inventory folders: every time you want to get the child objects but only those of type &#8216;Folder&#8217;:</p>

<pre class="expand:true lang:ps decode:true" title="LinkedView">$FolderView = Get-View -ViewType Folder -Property Name -Filter @{Name='RootFolder'}
# The call will retrieve ChildEntity property for current folder. No linked views are populated
$FolderView.UpdateViewData('ChildEntity')
# The call below will fill the LinkedView property
$FolderView.UpdateViewData('ChildEntity.*')
# or you can restrict the child objects retrieved to folders with only Name and ChildEntity properties obtained
$FolderView.UpdateViewData('[Folder]ChildEntity.Name','[Folder]ChildEntity.ChildEntity')</pre>

<p>The type restriction is neccessary when you specify the property path that include containers and this property doesn&#8217;t belong to all entities container can include. Thus</p>

<p><span class="lang:default decode:true  crayon-inline ">$FolderView.UpdateViewData(&#8216;ChildEntity.ChildEntity&#8217;)</span></p>

<p>won&#8217;t work because folder can include vm objects for which ChildEntity property isn&#8217;t defined.</p>

<p>Got it? Then another example of digging even deeper:</p>

<pre class="expand:true lang:ps decode:true" title="LinkedView">$VmView = Get-View -ViewType VirtualMachine -Property Name -Filter @{Name='TestVM'}
$VmView.UpdateViewData('Runtime.Host.Datastore.Name')
# will extract the names of all datastores connected to host where vm is currently running
$VmView.Runtime.LinkedView.Host.LinkedView.Datastore.Name</pre>

<p>So, instead of calling Get-View multiple times leverage UpdateViewData method call. It <a title="really accelerates" href="http://www.vnugglets.com/2012/08/even-faster-powercli-code-with-get-view.html" target="_blank">really accelerates</a> your scripts where you need to get nested view objects.</p>

<p>Now you are aware of the foundation of advanced PowerCLI scripting. Use Get-View in your scripts when processing the bulk of data and the speed is a vital factor.</p>

<p>When operating few objects stay with common impl-getting cmdlets not to loose the simplicity of your scripts.</p>

<p>There is another batch of interesting information I&#8217;m ready to share.</p>

<p>Stay tuned!</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2013/12/23/powershell-scheduled-job-output-redirection/">PowerShell scheduled job output redirection</a></h1>
        <span class="post-date">Dec 23 2013</span>
        <p>Scheduling the script execution is rather common task. You might know that it&#8217;s possible to manage scheduled tasks in PowerShell with built-in ScheduledTask module cmdlets. To keep track whether the task run successfully or not it&#8217;s quite useful to redirect the output of the script to a file. PowerShell allows output redirection for all stream types (standard/error/warning/etc), see <a title="TechNet about_Redirection help topic" href="http://technet.microsoft.com/en-us/library/hh847746.aspx" target="_blank">TechNet about_Redirection help topic</a>.</p>

<p>To be able to run your scripts with -Verbose option you should leverage Advanced_Functions syntax (see <a href="http://technet.microsoft.com/en-us/library/hh847806.aspx" title="about_Functions_Advanced">another Core About topic</a>). Just add couple of strings to the beginning of the script</p>

<pre class="lang:ps decode:true">[CmdletBinding()]
Param ()</pre>

<p>and use Write-Verbose cmdlet throughout the script where chatty output is needed. At first glance it seems to be an easy task to combine all mentioned together, but in fact I saw lots of questions across the web where people struggled to make it work. Indeed it took much effort before I succeeded. I&#8217;ve tested many different configuration and most of them didn&#8217;t work for me too. That&#8217;s what I came up with and it worked for me:</p>

<pre class="lang:ps decode:true">Register-ScheduledJob -Name Scheduled -Credential $Cred -Trigger (New-JobTrigger -Daily -At '11:00 PM') -ScriptBlock { D:\Scheduled.ps1 -Verbose *&gt; 'D:\Scheduled.log' }</pre>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2013/12/01/veeam-slow-backup/">Veeam slow backup</a></h1>
        <span class="post-date">Dec 1 2013</span>
        <p>One day I suddenly noticed that backup jobs could no longer fit the backup window. While investigating the issue I found tons of log records pointing that before processing every VM in the job Veeam tries to clean up all the snapshots created by its own for backup purposes. In some cases they were manually deleted or lost for some reason, but the records were still kept in the database.</p>

<p>So the root cause of slow backup is detected. To fix it first ensure that all backup jobs are stopped. If so, delete all snapshots with names containing &#8216;VEEAM&#8217; and &#8216;Consolidate helper&#8217; in vSphere inventory. Then go to Veeam database and clear the VmWareSnapshot table <strong>(DELETE FROM VmWareSnapshots)</strong>. It&#8217;s recommended to stop VeeamBackup service before executing the query against DB.</p>

<p>That&#8217;s it. Restart your jobs and enjoy the rates you used to see!</p>

    </div>
  
    <div class="post">
        <h1 class="post-title"><a href="https://purple-screen.com/2013/11/23/vcenter-converter-5-low-processing-rate/">vCenter Converter 5 low processing rate</a></h1>
        <span class="post-date">Nov 23 2013</span>
        <p>If you experience too slow conversion speed while doing P2V migration or other conversion task and see no reason for this, the solution might be to disable SSL encryption for data transfers between agent and server. To accomplish this open the file &#8216;C:\ProgramData\VMware\VMware vCenter Converter Standalone\converter-worker.xml&#8217;, navigate to <strong>nfc</strong> section of xml and set false in <strong>useSSL</strong> tag. Restarting &#8216;Converter Worker&#8217; service is required. Hope this&#8217;ll help!</p>

    </div>
  
</div>

<div class="pagination">
  
  <a class="pagination-item older" href="https://purple-screen.com/page/2/">Older</a>
  

  
  <span class="pagination-item newer">Newer</span>
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  </body>
</html>

